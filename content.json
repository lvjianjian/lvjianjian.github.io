[{"title":"网络表征学习论文总结","date":"2018-08-14T15:36:59.000Z","path":"2018/08/14/网络表征学习论文总结/","text":"Embedding真的是一个很神奇的东西，自动word2vec出世之后，感觉一切东西都在想办法做embedding。其实我觉得就是应该这样，在计算机的世界只有数字，因此如何表示一个东西也只能靠数字，而embedding正是让我们往这个方向靠近，合理的embedding显得尤为重要。 这里简单总结下看到的NE/NRL的embedding方法，会持续更新。 Title Author Venue Contribution DeepWalk: Online Learning of Social Representations Bryan Perozzi, Rami Al-Rfou, Steven Skiena KDD 2014 1. 使用random walk来对graph进行序列采样。 2. 然后用skip-gram算法来对采样出的序列进行embedding。思想很简单，但是确实很有效。 node2vec: Scalable Feature Learning for Networks Aditya Grover, Jure Leskovec KDD 2016 1. 相比较于DeepWalk, 定义了一个bias随机游走。DFS和BFS对于学到的结构信息是不一样的，BFS更注重局部信息的挖掘，DFS会在图中走得更深，更注重全局结构信息。2. 具体定义上，从t到v，返回t的未归一概率为1/p，到与t邻接的节点未归一概率为1，到与t不邻接的节点未归一概率为1/q, q控制着DFS/BFS的程度，p控制着返回原节点的程度。3. 然后在采样完之后仍然使用skip-gram。 Network Representation Learning with Rich Text Information Cheng Yang, Zhiyuan Liu, Deli Zhao, Maosong Sun, Edward Y. Chang IJCAI 2015 1. 论文说明了DeepWalk等同于M的矩阵分解，Mi,j 表示从i节点不超过k步到大j节点的概率。2. 因此该论文直接是用矩阵分解求向量，并且该论文还引入了节点信息，也是就再用一个矩阵 T 表示节点的额外信息, 最后优化 (M - WTHT) 的 F范数 加上 W 和 H 的L2 正则之和 Max-Margin DeepWalk Discriminative Learning of Network Representation Cunchao Tu, Weicheng Zhang, Zhiyuan Liu, Maosong Sun IJCAI 2016 Learning Graph Representations with Global Structural Information Shaosheng Cao, Wei Lu, Qiongkai Xu CIKM 2015","tags":[{"name":"NRL","slug":"NRL","permalink":"http://yoursite.com/tags/NRL/"},{"name":"NE","slug":"NE","permalink":"http://yoursite.com/tags/NE/"},{"name":"网络表征","slug":"网络表征","permalink":"http://yoursite.com/tags/网络表征/"}]},{"title":"Java垃圾收集","date":"2018-05-07T12:26:00.000Z","path":"2018/05/07/Java垃圾收集/","text":"Java垃圾收集1. 对象存活判定算法 引用计数法: 每个对象实例有一个引用计数，当有新变量指向这个对象实例时，引用计数器+1；当指向这个对象实例的引用超过了生命周期或者被设置为其它值时，引用计数器-1。对于引用计数为0的对象实例进行垃圾回收。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器-1。但是该方法无法检测出循环引用。 可达性分析算法: 将整个程序的引用看成是图，从GC Root开始向下搜索，没有遍历到的节点则为无用节点(不可达对象)。Java中可作为GC Root的对象有以下这些： 虚拟机栈中引用的对象（本地变量表） 方法区中静态属性引用的对象 方法区中常量引用的对象 本地方法栈中引用的对象（Native对象） 方法区回收：方法区可以不实现垃圾收集。要实现的话主要回收废弃常量和无用的类。回收废弃常量与回收堆中对象类似。而判定一个类是否无用则要满足以下三个条件： 该类的所有实例对象均已被回收。 加载该类的ClassLoader也被回收。 该类对应的java.lang.Class对象没有在任何地方引用，且无法在任何地方通过反射访问该类的方法。 2. Java中的四种引用状态： 强引用：只要强引用存在，垃圾收集器就不会回收掉该对象。方式：Object obj = new Object() 软引用：有用但非必需的对象。在系统将要发生内存溢出之前，将会把这些对象列进垃圾回收范围进行回收。方式：SoftReference 弱引用：非必需对象。只能生存到下一次垃圾收集发生之前。方式：WeakReference 虚引用：并不会决定其生命周期，且无法通过虚引用来获得对象。唯一目的是在这个对象被收集器回收时收到一个系统通知。方式：PhantomReference。(暂时其实不太明白有什么作用) 3. 垃圾收集算法 标记-清除算法: 从根集合开始扫描，对存活对象进行标记，标记完毕后，再扫描整个空间中未被标记的进行回收。从效率角度讲，标记和清除过程的效率都不高：从空间角度考虑，会产生大量不连续的内存碎片，导致之后需要分配较大对象时，无法找到足够的连续内存而不得不提前触发垃圾收集。 复制算法: 为了解决效率问题所提出的算法。将内存分为两块，每次只用其中一块，当一块内存用完时，将还存活着的对象复制到另外一块上，然后将之前已经用过的内存空间一次性清理掉。该方法在内存分配时无需考虑内存碎片等情况，只需要移动指针按照顺序分配，实现简单运行高效。但是内存缩小为原来一半，代价高。现代商业虚拟机不会按1:1划分。HotSpot默认Eden和Survivor按照8:1。 标记-整理算法: 复制算法在对象存活率较高时要进行较多的复制操作，效率将变低，因此提出该算法。和标记-清除算法一样需要进行标记操作，不同的是接下来让所有存活对象都向一端移动，然后清理掉边界以外的内存。 分代收集算法: 大多数现代商用虚拟机所采用的算法，其实质是以上算法的结合。根据对象的生命周期不同将内存划分为几块，然后根据各块的特点采用适当的收集算法。一般把Java堆分为新生代和老年代，在新生代中，每次垃圾收集将右大批对象死去，只有少量存活，就选用复制算法; 而老年代中因为对象存活率高、没有额外空间分配担保，就必须使用标记-清理或者标记-整理算法。","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"垃圾收集","slug":"垃圾收集","permalink":"http://yoursite.com/tags/垃圾收集/"}]},{"title":"交通流或速度预测论文总结","date":"2018-05-05T06:58:04.000Z","path":"2018/05/05/交通流或速度预测论文总结/","text":"简单总结下看到的交通预测的论文方法，会持续更新。 Title Author Venue Contribution Travel-time prediction with support vector regression Chun-Hsin Wu, Jan-Ming Ho, Der-Tsai Lee IEEE Trans. ITS 2004 针对单个路段的行驶时间/速度进行支持向量回归 Time Series Forecasting using Distribution Enhanced Linear Regression G Ristanoski，W Liu，J Bailey PAKDD 2013 1. 分布改变点检测并分段 2. 使用线性回归(LR)最小化各个分组各自的损失加上这些组损失的方差(论文中其实损失函数就是对各个组的MSE的RMSE) Long short-term memory neural network for traffic speed prediction using remote microwave sensor data Xiaolei Ma , Zhimin Tao , Yinhai Wang , Haiyang Yu , Yunpeng Wang Transportation Research Part C Emerging Technologies 2015 针对单个路段的行驶时间/速度，用LSTM预测 Short-term traffic flow prediction using seasonal ARIMA model with limited input data SV Kumar ，L Vanajakshi European Transport Research Review, 2015 使用Seasonal ARIMA 对单个路段的交通流进行预测 Utilizing Real-World Transportation Data for Accurate Traffic Prediction B Pan, U Demiryurek, C Shahabi ICDM 2012 1. 用均值预测和ARIMA预测结合预测单路段流量，使用历史数据判断用哪种方法更佳(通常长期预测用均值法更好) 2. 结合事件因素进行预测纠正。 Spatiotemporal Recurrent Convolutional Networks for Traffic Prediction in Transportation Networks Haiyang Yu, Zhihai Wu, Shuqin Wang, Yunpeng Wang, Xiaolei Ma Sensors, 2017 1. 对整个路网进行grid划分，统计各个grid的link speed的均值 2. 用DCNN（卷积，池化，全连接）学习各个时刻的grid speed matrix 3. 将各个时刻DCNN学出的features 代入 到LSTM 然后预测下一时刻的所有link speed 4. 预测多个可以将预测出的所有link speed再统计成grid matrix 再用DCNN学习代入之前的LSTM继续预测(有点类似NLP中预测后面的句子，把当前预测的单词作为输入不断预测下一个单词直到结束) Learning Traffic as Images: A Deep Convolutional Neural Network for Large-Scale Transportation Network Speed Prediction Xiaolei Ma, Zhuang Dai, Zhengbing He, Jihui Ma, Yong Wang, Yunpeng Wang Sensors, 2017 1. 针对环路或者路网，构建二维速度matrix，横为路段，纵为时间 2. 用DCNN(卷积 + 池化)对矩阵学习，最后用全连接对所有路段进行预测 Deep Spatio-Temporal Residual Networks for Citywide Crowd Flows Prediction Junbo Zhang, Yu Zheng, Dekang Qi AAAI, 2017 1. 划分grid，建立输入、输出流tensor 2. 使用深度残差网络学习特征 3. 将趋势划分为三个等级(近期趋势，日趋势和周趋势)分别建模 4. 融合外部因素如天气，事件等 Traffic Speed Prediction and Congestion Source Exploration: A Deep Learning Method Jingyuan Wang, Qian Gu, Junjie Wu, Guannan Liu, Zhang Xiong ICDM, 2016 1. 针对环路，对每个路段构建一个时空矩阵(将该路段的前后路段以及近期时间的速度构成速度矩阵) 2. 使用卷积和池化学习矩阵，同时引入误差反馈机制，即将之前的预测与实际的误差作为输入（实现时候是以rnn的方式实现），通过误差反馈来学习突发状况带来的路况突变 3. 通过神经网络权重计算道路重要性，也就是更可能拥挤的区域 (这一段还没完全理解，后续还需要再看下) An Improved Fuzzy Neural Network for Traffic Speed Prediction Considering Periodic Characteristic Jinjun Tang, Fang Liu, Yajie Zou, Weibin Zhang, Yinhai Wang IEEE Trans. ITS, 2017","tags":[{"name":"交通流预测","slug":"交通流预测","permalink":"http://yoursite.com/tags/交通流预测/"},{"name":"交通速度预测","slug":"交通速度预测","permalink":"http://yoursite.com/tags/交通速度预测/"}]},{"title":"Java内存模型","date":"2018-05-02T13:43:18.000Z","path":"2018/05/02/Java内存模型/","text":"Java内存区域1. 运行时数据区JVM虚拟机管理的内存会在执行时被划分为以下几个区域,总体的内存模型如下：其中方法区和Java堆是所有线程共享的，而JVM栈、本地方法栈、程序计数器是线程私有的。 程序计数器 一块较小的内存, 可以看成是当前线程所执行的字节码的行号指示器，目的是为了引导字节码解析的顺序（字节码解释器通过改变这个计数器的值来选取下一条要执行的字节码指令） 如果线程执行一个Java方法，则程序计数器存放虚拟机字节码指令的地址，如果执行一个Native放法，则为空 唯一一个没有规定任何OutOfMemoryError情况的区域 JVM栈 Java方法执行时的内存模型,每一个方法执行的同时会创建一个栈帧（Stack Frame），用于存放局部变量表，操作数栈，动态链接，放法出口等信息。每一个方法的执行对应着栈帧在JVM栈中的入栈、出栈过程。 局部变量表:存放编译期可知的各种基本类型、对象引用类型和returnAddress类型（指向一条字节码指令的地址，即函数返回地址）。局部变量表所需内存在编译期确定，进入一个方法时，方法在栈帧中所分配的局部变量是完全确定的，不可动态改变大小。32位数据占用一个slot, 64位数据占用两个slot（long，double）,引用类型可能占一个也可能占两个。 操作数栈：最大深度由编译期确定。用于存放JVM从局部变量表复制的常量或者变量，提供提取，及结果入栈，也用于存放调用方法需要的参数及接受方法返回的结果。 动态链接：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。 方法返回地址：当执行引擎遇到任意一个方法返回的字节码指令或者未在方法内处理的异常时会退出该方法。退出时需要返回到方法被调用的位置。方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。（一般来说，方法正常退出时，调用者的PC计数器的值就可以作为返回地址，栈帧中很可能保存了这个计数器值; 方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息）方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，如果有返回值，则把它压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令。 规定了两种异常状况，如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常; 如果虚拟机扩展时无法申请到足够的内存，将抛出OutOfMemoryError异常。 本地方法栈 作用与JVM栈类似，区别时本地方法栈为虚拟机使用到的native方法服务。 有的虚拟机会把本地方法栈和JVM栈合二为一。 堆 虚拟机启动时创建，用于存放对象实例和数组，是垃圾收集器管理的主要区域。 由年轻代、年老代、永久代组成。（JDK8开始hotspot将永久代移除，取而代之的是Metaspace） 可以处于物理上不连续的内存空间中，只要逻辑上连续即可。 若在堆中没有完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。 方法区 用于存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等。 与堆一样逻辑上连续即可，还可以选择不实现垃圾收集，若要回收则主要针对常量池和对类型的卸载。 一些虚拟机使用”永久代”(Permanent Generation)来实现方法区 当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 运行时常量池 方法区的一部分。用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。 Java语言并不要求常量一定只有编译期才能产生，也可能在运行时将新的常量放入池中，这种特性被开发人员利用得比较多是便是String类的intern方法。 当常量池无法再申请到内存时会抛出OutOfMemoryError异常。 2. Hotspot虚拟机对象 对象的创建 当遇到一条new指令时，检查这个指令的参数能否在常量池中定位到一个类的符号引用，并且检测这个符号引用代表的类是否已经加载、解析和初始化。如果没有则先执行相应的类加载过程。 然后分配内存。内存大小在类加载完成后便可确定。因此分配空间的任务等同于把一块内存从Java堆中划分出来。这里有两种策略，使用哪种分配方式由Java堆是否规整决定，而是否规整由垃圾收集器算法决定。 指针碰撞：假设Java堆中的内存绝对规整，即所有用过的内存放在一边，空闲的内存在另一边，中间是一个作为分界点的指示器，那分配内存等同于把指针向空闲边挪动一段与对象大小相等的距离。 空闲列表：假设Java堆中的内存不规整，已使用的内存和未分配的内存相互交织，那就需要维护一个列表去记录哪些内存块可用，分配的时候找一个足够大的空间划分给对象实例，并更新列表上的记录。 虚拟机需要对对象进行必要的设置，例如这个对象是哪个类的实例、如何找到类的元数据信息等。这些信息存放在对象头中。 执行 &lt; init &gt; 方法，把对象按照程序员的意愿进行初始化。 对象的内存布局 主要有3块区域：对象头、实例数据和对齐填充。 对象头：包含两部分。一是记录对象自身的运行时数据如哈希码、GC分代年龄、锁状态标志、线程持有的锁等。另一部分是类型指针，即指向它的类元数据的指针（注意不是所有虚拟机都必须在这里保留类型指针）。 实例数据：存储代码中定义的各种类型的字段。 对齐填充：要求对象起始位置是8字节的整数倍，也就是对象大小是8字节的整数倍。当对象实例数据部分没有对齐时则需要填充补全。 对象的访问定位为了使用对象，Java程序需要通过栈上的reference数据操作堆上的具体对象。这里的访问方式主要有两种： 句柄访问：Java堆划分一块内存作为句柄池，reference存储句柄地址，句柄中包含对象实例数据和类型数据的地址，如下图 直接指针访问：reference存储的直接就是对象地址，如下 3. 内存参数设置 堆大小设置 -Xms：堆最小内存，即初始内存 -Xmx：堆最大内存 -Xmn：年轻代大小 -Xss：JVM栈大小 -XX:NewRatio：年轻代与年老代的比值 -XX:SurvivorRatio：年轻代中Eden区与Survivor区的比值 -XX:PermSize：永久代大小(JDK8 已被MetaspaceSize取代) -XX:MaxPermSize：最大永久代大小(JDK8 已被MaxMetaspaceSize取代) -XX:MetaspaceSize：元空间大小 -XX:MaxMetaspaceSize：最大元空间大小 -XX:MaxTenuringThreshold：垃圾最大年龄","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"内存模型","slug":"内存模型","permalink":"http://yoursite.com/tags/内存模型/"}]},{"title":"记阿里一面","date":"2018-04-22T13:53:40.000Z","path":"2018/04/22/记阿里一面/","text":"记阿里一面 前几天阿里来了电一面，今天记录一下问题，也方便以后面试时查阅。 阿里面的是上海财富部的java开发，偏机器学习方面。 java写完程序（.java）,到执行都经历了哪些。(java程序执行过程,包括java编译以及jvm执行) 数据库中一、二、三以及BC范式的作用。（应该针对减少冗余，防止不一致性方面作答吧） linux 查看进程命令 (top,htop, ps -ef 等) 了解哪些大数据平台/框架 （答了spark，因此让我介绍下spark） 讲下logistic回归 讲下DL中的激活函数","tags":[{"name":"面经","slug":"面经","permalink":"http://yoursite.com/tags/面经/"},{"name":"阿里","slug":"阿里","permalink":"http://yoursite.com/tags/阿里/"}]},{"title":"lightgbm参数","date":"2017-10-14T05:59:45.000Z","path":"2017/10/14/lightgbm参数/","text":"lightgbm 参数介绍之前介绍了下xgboost的重要参数。今天把lightgbm的参数整理一下，方便以后查阅。 Core Paramater 这是一般会设置的核心参数 objective: regression, regression_l2(mse), regression_l1(mae), huber, fair, poisson, binary, lambdarank, multiclass boosting: gbdt, rf, dart, goss num_rounds: boosting的数量 learning_rate: 学习率 num_leaves: 单一树中的叶子数 num_threads: 最好设置为CPU核数 Learning Control Paramater 这些是控制学习的一些参数，只选取了个gbdt有关的一些。其他后续补充。 max_depth min_data_in_leaf min_sum_hessian_in_leaf : 类似min_data_in_leaf feature_fraction：类似xgboost中的colsample_bytree feature_fraction_seed bagging_fraction：随机选择一部分数据不重新采样 bagging_freq bagging_seed early_stopping_round lambda_l1 lambda_l2 min_gain_to_split：划分节点的最小提升 Metric Parameter metric 评估参数，主要有：l1,l2,l2_root(rmse),huber,fair,poisson,ndcg,map,auc,binary_logloss,binary_error,multi_logloss,multi_error metric_freq: 输出频率 还有不少参数暂时没怎么用到，以后再补充。","tags":[{"name":"lightgbm","slug":"lightgbm","permalink":"http://yoursite.com/tags/lightgbm/"},{"name":"boost","slug":"boost","permalink":"http://yoursite.com/tags/boost/"},{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/机器学习/"}]},{"title":"xgboost参数","date":"2017-10-13T12:46:10.000Z","path":"2017/10/13/xgboost参数/","text":"xgboost 参数介绍这里记录下xgboost的一些重要参数，方便以后查阅。 Task 参数 objective 定义学习目标, 默认值为 reg:linear reg:linear —— 线性回归 reg:logistic —— 逻辑回归 binary:logistic —— 二分类逻辑回归，输出概率 binary:logitraw —— 二分类逻辑回归，输出wTx（logistic转换前的得分） count:poisson —— 计数数据的泊松回归，输出泊松分布的均值（max_delta_step默认设置为0.7） multi:softmax —— 多分类，需要设置num_class multi:softprob —— 多分类，输出在各个类别下的概率 rank:pairwise —— 任务排序，通过最小化pairwise loss求解 base_score 所有实例、global bias的最初预测得分，默认0.5 eval_metric 评估指标，不用objective有不同的默认值 rmse logloss error 错误率 merror 多分类错误率 mlogloss auc ndcg (normalized discounted cumulative gain) map 平均准确率 ndcg@n；map@n；ndcg-；map-；ndcg@n-；map@n- booster 参数 eta：为了防止过拟合，更新过程中用到的收缩步长。在每次提升计算之后，算法会直接获得新特征的权重。 eta通过缩减特征的权重使提升计算过程更加保守。缺省值为0.3。 类似学习率 gamma : 默认值为0，为了对树的叶子节点做进一步的分割而必须设置的损失减少的最小值。该值越大，算法越保守 max_depth: 树的最大深度 min_child_weight：树的叶子节点最小权重 max_delta_step：如果该值为0，就是没有限制；如果设为一个正数，可以使每一步更新更加保守通常情况下这一参数是不需要设置的 subsample：选取子样本的比率 colsample_bytree： 选取的特征的比率 lambda：l2正则 alpha：l1正则 一般参数 booster: gbtree和gblinear。gbtree使用基于树的模型进行提升计算，gblinear使用线性模型进行提升计算。缺省值为gbtree。还有一个dart。 silent: 取0时表示打印出运行时信息，取1时表示以缄默方式运行，不打印运行时信息。缺省值为0。 nthread: 运行时的线程数。缺省值是当前系统可以获得的最大线程数。 一般会设置 objective,eval_metric,eta,max_depth,subsample,colsample_bytree防止过拟合还会设置 gamma,min_child_weight,lambda,alphasilent一般设置为1","tags":[{"name":"boost","slug":"boost","permalink":"http://yoursite.com/tags/boost/"},{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/机器学习/"},{"name":"xgboost","slug":"xgboost","permalink":"http://yoursite.com/tags/xgboost/"}]},{"title":".ssh文件权限","date":"2017-09-18T04:15:36.000Z","path":"2017/09/18/ssh文件权限/","text":"在ssh中无密码登录的文件权限问题.ssh文件夹的权限为700.ssh中authorized_keys文件的权限为600","tags":[{"name":"ssh","slug":"ssh","permalink":"http://yoursite.com/tags/ssh/"},{"name":"文件权限","slug":"文件权限","permalink":"http://yoursite.com/tags/文件权限/"}]},{"title":"python中的抽象方法，抽象类，私有，保护方法","date":"2017-04-06T07:50:32.000Z","path":"2017/04/06/python中的抽象方法，抽象类，私有，保护方法/","text":"平时在python基本不怎么写类，都是定义方法到处调用。但是感觉把公共逻辑封装成抽象类，再继承写独立的逻辑更快更清晰。由于python 没有抽象类、接口的概念，所以要实现这种功能得abc.py 这个类库,具体方式如下：1234567891011121314151617181920212223242526272829from abc import ABCMeta, abstractmethodclass abstract1(object): __metaclass__ = ABCMeta @abstractmethod def print1(self):pass def print2(self): print \"Test1 print2\" def __si(self): print \"abstract1 si\" def gong(self): print \"abstarct gong\" def _pro(self): print \"abstract pro\"class imp1(abstract1): __metaclass__ = ABCMeta def print1(self): print \"imp1 pring1\" def imp_si(self): abstract1.gong() abstract1._pro() _metaclass__ = ABCMeta可以保证在实例化一个抽象类的时候抛出异常。 @abstractmethod放在要定义的抽象方法上。 私有方法用2个下划线定义，如__private_functon()，子类无法调用。 保护方法用1个下划线定义，如_protected_function()，子类可以调用。","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"抽象","slug":"抽象","permalink":"http://yoursite.com/tags/抽象/"}]},{"title":"整型操作中判断是否超出边界","date":"2017-04-05T06:00:08.000Z","path":"2017/04/05/整形操作中判断是否超出边界/","text":"今天leetcode刷题时候遇到了对整型数据的操作，想要对超出最大最小值进行特殊处理。一开始的思路是在对整型数据操作时候存成long型，这样就可以很简单地在末尾进行判断了，但是想到如果是对long做操作难道再把数据类型扩大成biginteger么？因此另一种办法就是在每次操作前进行判断，由于在操作后，其值可能已经超界发生改变就很难判断，所以在操作前用最大或者最小值的整除和取余的值和其判断即可。12//是否会超出最大值if (sum &gt; Integer.MAX_VALUE / 10|| (sum == Integer.MAX_VALUE/10 &amp;&amp; digit &gt; Integer.MAX_VALUE % 10)) 12//是否会超出最小值if(sum &lt; Integer.MIN_VALUE / 10||(sum == Integer.MIN_VALUE/10 &amp;&amp; digit &lt; Integer.MIN_VALUE % 10)) leetcode第8题是自己编写一个c的atoi，将一个字符串转成数字，遇到字母即停止读入。超出边界按边界返回，其实现如下：123456789101112131415161718192021222324252627282930313233public int myAtoi(String str) &#123; if (str == null) return 0; str = str.trim(); int sum = 0; boolean findSign = false; int sign = 1;//符号位 boolean findInteger = false; for (int i = 0; i &lt; str.length(); i++) &#123; char a = str.charAt(i); if (a &gt;= '0' &amp;&amp; a &lt;= '9') &#123; int digit = sign * (a - '0'); //判断是否会超出int最大值范围 if (sum &gt; Integer.MAX_VALUE / 10 || (sum == Integer.MAX_VALUE/10 &amp;&amp; digit &gt; Integer.MAX_VALUE % 10))&#123; return Integer.MAX_VALUE; &#125;else if(sum &lt; Integer.MIN_VALUE / 10 || (sum == Integer.MIN_VALUE/10 &amp;&amp; digit &lt; Integer.MIN_VALUE % 10) )&#123; return Integer.MIN_VALUE; &#125; sum = sum * 10 + digit; findInteger = true; &#125;else if(a == '-' &amp;&amp; !findSign &amp;&amp; !findInteger)&#123; findSign = true; sign = -1; &#125;else if(a == '+' &amp;&amp; !findSign &amp;&amp; !findInteger)&#123; findSign = true; &#125; else &#123; break; &#125; &#125; return sum; &#125;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"整型操作","slug":"整型操作","permalink":"http://yoursite.com/tags/整型操作/"}]},{"title":"remarkable安装","date":"2017-03-24T07:09:04.000Z","path":"2017/03/24/remarkable安装/","text":"今天在用typora的时候发现它在修改文档的时候有些不方便，而且现在我的显示屏也很大，完全可以用双栏的markdown编辑器。因此就决定用remarkable。 首先在remarkable下载页(linux)下载。 这里有deb，prm，github源码等形式。我下的是deb，因为有好多依赖问题，这种东西还是让软件帮我们解决吧。 然后安装1sudo dpkg -i remarkable_1.87_all.deb 发现各种依赖不让装。然后尝试先把其中一个依赖装起来，发现它们似乎相互依赖的样子。怎么样都不行。最后其实只要这些依赖一起安装就可以了。 1sudo apt-get install -f 依赖安装好了就可以安装remarkable了。 最后使用1remarkable &amp;","tags":[{"name":"remarkable","slug":"remarkable","permalink":"http://yoursite.com/tags/remarkable/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://yoursite.com/tags/ubuntu/"},{"name":"安装","slug":"安装","permalink":"http://yoursite.com/tags/安装/"}]},{"title":"markdown语法","date":"2017-03-24T05:12:31.000Z","path":"2017/03/24/markdown语法/","text":"标题12# 一级标题## 二级标题 标题总共由6级，用1个#到6个#表示，#号后面需要跟一个空格。这里不作示例了。 列表无序列表123* 1* 2* 3 用*表示无序列表，后面需要加一个空格 1 2 3 有序列表1231. 12. 23. 3 用数字加点的形式表示有序列表，注意空格。 1 2 3 引用1&gt; 这里是引用内容 这里是引用内容 链接和图片链接1[百度](www.baidu.com &quot;百度&quot;) 百度 图片12![](http://mouapp.com/Mou_128.png)![](markdown语法/oschina.png) 图片相比链接多了一个感叹号 注意:这里我用的是hexo，需要另下插件才能把本地的图片显示出来。具体参考http://www.tuicool.com/articles/umEBVfI. 此外根目录下_config.yml中的post_asset_folder设置为true 代码块代码放入由`组成的6个点中，上下各3个 123def set_ch(): mpl.rcParams['font.sans-serif'] = ['simhei'] mpl.rcParams['axes.unicode_minus'] = False","tags":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"},{"name":"语法","slug":"语法","permalink":"http://yoursite.com/tags/语法/"}]},{"title":"matplotlib中文显示","date":"2017-03-24T05:08:51.000Z","path":"2017/03/24/matplotlib中文显示/","text":"matplotlib中文显示今天在ubuntu下用matplotlib显示中文的时候出现了乱码，之前在windows上用了下面这段代码就可以了。123def set_ch(): mpl.rcParams['font.sans-serif'] = ['simhei'] # 指定默认字体 mpl.rcParams['axes.unicode_minus'] = False # 解决保存图像是负号'-'显示为方块的问题 但是在ubuntu上还是显示不出。主要原因是ubuntu上没有这个字体。所以从windows上把黑体字体搬到ubuntu的下面这个路径下。1/usr/local/lib/python2.7/dist-packages/matplotlib/mpl-data/fonts 可能每台机子具体路径不太一样，需要自己找下。我是通过print matplotlib.__file__找到的。 然后删除~/.cache/matplotlib的缓冲目录就可以了。","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"matplotlib","slug":"matplotlib","permalink":"http://yoursite.com/tags/matplotlib/"},{"name":"中文显示","slug":"中文显示","permalink":"http://yoursite.com/tags/中文显示/"}]}]