[{"title":"Java内存模型","date":"2018-05-02T13:43:18.000Z","path":"2018/05/02/Java内存模型/","text":"Java内存区域1. 运行时数据区JVM虚拟机管理的内存会在执行时被划分为以下几个区域,总体的内存模型如下：其中方法区和Java堆是所有线程共享的，而JVM栈、本地方法栈、程序计数器是线程私有的。 程序计数器 一块较小的内存, 可以看成是当前线程所执行的字节码的行号指示器，目的是为了引导字节码解析的顺序（字节码解释器通过改变这个计数器的值来选取下一条要执行的字节码指令）。 如果线程执行一个Java方法，则程序计数器存放虚拟机字节码指令的地址，如果执行一个Native放法，则为空。 唯一一个没有规定任何OutOfMemoryError情况的区域。 JVM栈 Java方法执行时的内存模型,每一个方法执行的同时会创建一个栈帧（Stack Frame），用于存放局部变量表，操作数栈，动态链接，放法出口等信息。每一个方法的执行对应着栈帧在JVM栈中的入栈、出栈过程。 局部变量表:存放编译期可知的各种基本类型、对象引用类型和returnAddress类型（指向一条字节码指令的地址，即函数返回地址）。局部变量表所需内存在编译期确定，进入一个方法时，方法在栈帧中所分配的局部变量是完全确定的，不可动态改变大小。32位数据占用一个slot, 64位数据占用两个slot（long，double）,引用类型可能占一个也可能占两个。 操作数栈：最大深度由编译期确定。用于存放JVM从局部变量表复制的常量或者变量，提供提取，及结果入栈，也用于存放调用方法需要的参数及接受方法返回的结果。 动态链接：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。 方法返回地址：当执行引擎遇到任意一个方法返回的字节码指令或者未在方法内处理的异常时会退出该方法。退出时需要返回到方法被调用的位置。方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。（一般来说，方法正常退出时，调用者的PC计数器的值就可以作为返回地址，栈帧中很可能保存了这个计数器值; 方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息）方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，如果有返回值，则把它压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令。 规定了两种异常状况，如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常; 如果虚拟机扩展时无法申请到足够的内存，将抛出OutOfMemoryError异常。 本地方法栈 作用与JVM栈类似，区别时本地方法栈为虚拟机使用到的native方法服务。 有的虚拟机会把本地方法栈和JVM栈合二为一。 堆 虚拟机启动时创建，用于存放对象实例和数组，是垃圾收集器管理的主要区域。 可以处于物理上不连续的内存空间中，只要逻辑上连续即可。 若在堆中没有完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。 方法区 于存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等。 与堆一样逻辑上连续即可，还可以选择不实现垃圾收集，若要回收则主要针对常量池和对类型的卸载。 当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 运行时常量池 方法区的一部分。用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。 Java语言并不要求常量一定只有编译期才能产生，也可能在运行时将新的常量放入池中，这种特性被开发人员利用得比较多是便是String类的intern方法。 当常量池无法再申请到内存时会抛出OutOfMemoryError异常。 2. Hotspot虚拟机对象 对象的创建 当遇到一条new指令时，检查这个指令的参数能否在常量池中定位到一个类的符号引用，并且检测这个符号引用代表的类是否已经加载、解析和初始化。如果没有则先执行相应的类加载过程。 然后分配内存。内存大小在类加载完成后便可确定。因此分配空间的任务等同于把一块内存从Java堆中划分出来。这里有两种策略，使用哪种分配方式由Java堆是否规整决定，而是否规整由垃圾收集器算法决定。 指针碰撞：假设Java堆中的内存绝对规整，即所有用过的内存放在一边，空闲的内存在另一边，中间是一个作为分界点的指示器，那分配内存等同于把指针向空闲边挪动一段与对象大小相等的距离。 空闲列表：假设Java堆中的内存不规整，已使用的内存和未分配的内存相互交织，那就需要维护一个列表去记录哪些内存块可用，分配的时候找一个足够大的空间划分给对象实例，并更新列表上的记录。 虚拟机需要对对象进行必要的设置，例如这个对象是哪个类的实例、如何找到类的元数据信息等。这些信息存放在对象头中。 执行 &lt; init &gt; 方法，把对象按照程序员的意愿进行初始化。 对象的内存布局 主要有3块区域：对象头、实例数据和对齐填充。 对象头：包含两部分。一是记录对象自身的运行时数据如哈希码、GC分代年龄、锁状态标志、线程持有的锁等。另一部分是类型指针，即指向它的类元数据的指针（注意不是所有虚拟机都必须在这里保留类型指针）。 实例数据：存储代码中定义的各种类型的字段。 对齐填充：要求对象起始位置是8字节的整数倍，也就是对象大小是8字节的整数倍。当对象实例数据部分没有对齐时则需要填充补全。 对象的访问定位为了使用对象，Java程序需要通过栈上的reference数据操作堆上的具体对象。这里的访问方式主要有两种： 句柄访问：Java堆划分一块内存作为句柄池，reference存储句柄地址，句柄中包含对象实例数据和类型数据的地址，如下图 直接指针访问：reference存储的直接就是对象地址，如下","tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"内存模型","slug":"内存模型","permalink":"http://yoursite.com/tags/内存模型/"}]},{"title":"记阿里一面","date":"2018-04-22T13:53:40.000Z","path":"2018/04/22/记阿里一面/","text":"记阿里一面 前几天阿里来了电一面，今天记录一下问题，也方便以后面试时查阅。 阿里面的是上海财富部的java开发，偏机器学习方面。 java写完程序（.java）,到执行都经历了哪些。(java程序执行过程,包括java编译以及jvm执行) 数据库中一、二、三以及BC范式的作用。（应该针对减少冗余，防止不一致性方面作答吧） linux 查看进程命令 (top,htop, ps -ef 等) 了解哪些大数据平台/框架 （答了spark，因此让我介绍下spark） 讲下logistic回归 讲下DL中的激活函数","tags":[{"name":"面经","slug":"面经","permalink":"http://yoursite.com/tags/面经/"},{"name":"阿里","slug":"阿里","permalink":"http://yoursite.com/tags/阿里/"}]},{"title":"lightgbm参数","date":"2017-10-14T05:59:45.000Z","path":"2017/10/14/lightgbm参数/","text":"lightgbm 参数介绍之前介绍了下xgboost的重要参数。今天把lightgbm的参数整理一下，方便以后查阅。 Core Paramater 这是一般会设置的核心参数 objective: regression, regression_l2(mse), regression_l1(mae), huber, fair, poisson, binary, lambdarank, multiclass boosting: gbdt, rf, dart, goss num_rounds: boosting的数量 learning_rate: 学习率 num_leaves: 单一树中的叶子数 num_threads: 最好设置为CPU核数 Learning Control Paramater 这些是控制学习的一些参数，只选取了个gbdt有关的一些。其他后续补充。 max_depth min_data_in_leaf min_sum_hessian_in_leaf : 类似min_data_in_leaf feature_fraction：类似xgboost中的colsample_bytree feature_fraction_seed bagging_fraction：随机选择一部分数据不重新采样 bagging_freq bagging_seed early_stopping_round lambda_l1 lambda_l2 min_gain_to_split：划分节点的最小提升 Metric Parameter metric 评估参数，主要有：l1,l2,l2_root(rmse),huber,fair,poisson,ndcg,map,auc,binary_logloss,binary_error,multi_logloss,multi_error metric_freq: 输出频率 还有不少参数暂时没怎么用到，以后再补充。","tags":[{"name":"lightgbm","slug":"lightgbm","permalink":"http://yoursite.com/tags/lightgbm/"},{"name":"boost","slug":"boost","permalink":"http://yoursite.com/tags/boost/"},{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/机器学习/"}]},{"title":"xgboost参数","date":"2017-10-13T12:46:10.000Z","path":"2017/10/13/xgboost参数/","text":"xgboost 参数介绍这里记录下xgboost的一些重要参数，方便以后查阅。 Task 参数 objective 定义学习目标, 默认值为 reg:linear reg:linear —— 线性回归 reg:logistic —— 逻辑回归 binary:logistic —— 二分类逻辑回归，输出概率 binary:logitraw —— 二分类逻辑回归，输出wTx（logistic转换前的得分） count:poisson —— 计数数据的泊松回归，输出泊松分布的均值（max_delta_step默认设置为0.7） multi:softmax —— 多分类，需要设置num_class multi:softprob —— 多分类，输出在各个类别下的概率 rank:pairwise —— 任务排序，通过最小化pairwise loss求解 base_score 所有实例、global bias的最初预测得分，默认0.5 eval_metric 评估指标，不用objective有不同的默认值 rmse logloss error 错误率 merror 多分类错误率 mlogloss auc ndcg (normalized discounted cumulative gain) map 平均准确率 ndcg@n；map@n；ndcg-；map-；ndcg@n-；map@n- booster 参数 eta：为了防止过拟合，更新过程中用到的收缩步长。在每次提升计算之后，算法会直接获得新特征的权重。 eta通过缩减特征的权重使提升计算过程更加保守。缺省值为0.3。 类似学习率 gamma : 默认值为0，为了对树的叶子节点做进一步的分割而必须设置的损失减少的最小值。该值越大，算法越保守 max_depth: 树的最大深度 min_child_weight：树的叶子节点最小权重 max_delta_step：如果该值为0，就是没有限制；如果设为一个正数，可以使每一步更新更加保守通常情况下这一参数是不需要设置的 subsample：选取子样本的比率 colsample_bytree： 选取的特征的比率 lambda：l2正则 alpha：l1正则 一般参数 booster: gbtree和gblinear。gbtree使用基于树的模型进行提升计算，gblinear使用线性模型进行提升计算。缺省值为gbtree。还有一个dart。 silent: 取0时表示打印出运行时信息，取1时表示以缄默方式运行，不打印运行时信息。缺省值为0。 nthread: 运行时的线程数。缺省值是当前系统可以获得的最大线程数。 一般会设置 objective,eval_metric,eta,max_depth,subsample,colsample_bytree防止过拟合还会设置 gamma,min_child_weight,lambda,alphasilent一般设置为1","tags":[{"name":"boost","slug":"boost","permalink":"http://yoursite.com/tags/boost/"},{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/机器学习/"},{"name":"xgboost","slug":"xgboost","permalink":"http://yoursite.com/tags/xgboost/"}]},{"title":".ssh文件权限","date":"2017-09-18T04:15:36.000Z","path":"2017/09/18/ssh文件权限/","text":"在ssh中无密码登录的文件权限问题.ssh文件夹的权限为700.ssh中authorized_keys文件的权限为600","tags":[{"name":"ssh","slug":"ssh","permalink":"http://yoursite.com/tags/ssh/"},{"name":"文件权限","slug":"文件权限","permalink":"http://yoursite.com/tags/文件权限/"}]},{"title":"python中的抽象方法，抽象类，私有，保护方法","date":"2017-04-06T07:50:32.000Z","path":"2017/04/06/python中的抽象方法，抽象类，私有，保护方法/","text":"平时在python基本不怎么写类，都是定义方法到处调用。但是感觉把公共逻辑封装成抽象类，再继承写独立的逻辑更快更清晰。由于python 没有抽象类、接口的概念，所以要实现这种功能得abc.py 这个类库,具体方式如下：1234567891011121314151617181920212223242526272829from abc import ABCMeta, abstractmethodclass abstract1(object): __metaclass__ = ABCMeta @abstractmethod def print1(self):pass def print2(self): print \"Test1 print2\" def __si(self): print \"abstract1 si\" def gong(self): print \"abstarct gong\" def _pro(self): print \"abstract pro\"class imp1(abstract1): __metaclass__ = ABCMeta def print1(self): print \"imp1 pring1\" def imp_si(self): abstract1.gong() abstract1._pro() _metaclass__ = ABCMeta可以保证在实例化一个抽象类的时候抛出异常。 @abstractmethod放在要定义的抽象方法上。 私有方法用2个下划线定义，如__private_functon()，子类无法调用。 保护方法用1个下划线定义，如_protected_function()，子类可以调用。","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"抽象","slug":"抽象","permalink":"http://yoursite.com/tags/抽象/"}]},{"title":"整型操作中判断是否超出边界","date":"2017-04-05T06:00:08.000Z","path":"2017/04/05/整形操作中判断是否超出边界/","text":"今天leetcode刷题时候遇到了对整型数据的操作，想要对超出最大最小值进行特殊处理。一开始的思路是在对整型数据操作时候存成long型，这样就可以很简单地在末尾进行判断了，但是想到如果是对long做操作难道再把数据类型扩大成biginteger么？因此另一种办法就是在每次操作前进行判断，由于在操作后，其值可能已经超界发生改变就很难判断，所以在操作前用最大或者最小值的整除和取余的值和其判断即可。12//是否会超出最大值if (sum &gt; Integer.MAX_VALUE / 10|| (sum == Integer.MAX_VALUE/10 &amp;&amp; digit &gt; Integer.MAX_VALUE % 10)) 12//是否会超出最小值if(sum &lt; Integer.MIN_VALUE / 10||(sum == Integer.MIN_VALUE/10 &amp;&amp; digit &lt; Integer.MIN_VALUE % 10)) leetcode第8题是自己编写一个c的atoi，将一个字符串转成数字，遇到字母即停止读入。超出边界按边界返回，其实现如下：123456789101112131415161718192021222324252627282930313233public int myAtoi(String str) &#123; if (str == null) return 0; str = str.trim(); int sum = 0; boolean findSign = false; int sign = 1;//符号位 boolean findInteger = false; for (int i = 0; i &lt; str.length(); i++) &#123; char a = str.charAt(i); if (a &gt;= '0' &amp;&amp; a &lt;= '9') &#123; int digit = sign * (a - '0'); //判断是否会超出int最大值范围 if (sum &gt; Integer.MAX_VALUE / 10 || (sum == Integer.MAX_VALUE/10 &amp;&amp; digit &gt; Integer.MAX_VALUE % 10))&#123; return Integer.MAX_VALUE; &#125;else if(sum &lt; Integer.MIN_VALUE / 10 || (sum == Integer.MIN_VALUE/10 &amp;&amp; digit &lt; Integer.MIN_VALUE % 10) )&#123; return Integer.MIN_VALUE; &#125; sum = sum * 10 + digit; findInteger = true; &#125;else if(a == '-' &amp;&amp; !findSign &amp;&amp; !findInteger)&#123; findSign = true; sign = -1; &#125;else if(a == '+' &amp;&amp; !findSign &amp;&amp; !findInteger)&#123; findSign = true; &#125; else &#123; break; &#125; &#125; return sum; &#125;","tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"整型操作","slug":"整型操作","permalink":"http://yoursite.com/tags/整型操作/"}]},{"title":"remarkable安装","date":"2017-03-24T07:09:04.000Z","path":"2017/03/24/remarkable安装/","text":"今天在用typora的时候发现它在修改文档的时候有些不方便，而且现在我的显示屏也很大，完全可以用双栏的markdown编辑器。因此就决定用remarkable。 首先在remarkable下载页(linux)下载。 这里有deb，prm，github源码等形式。我下的是deb，因为有好多依赖问题，这种东西还是让软件帮我们解决吧。 然后安装1sudo dpkg -i remarkable_1.87_all.deb 发现各种依赖不让装。然后尝试先把其中一个依赖装起来，发现它们似乎相互依赖的样子。怎么样都不行。最后其实只要这些依赖一起安装就可以了。 1sudo apt-get install -f 依赖安装好了就可以安装remarkable了。 最后使用1remarkable &amp;","tags":[{"name":"remarkable","slug":"remarkable","permalink":"http://yoursite.com/tags/remarkable/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://yoursite.com/tags/ubuntu/"},{"name":"安装","slug":"安装","permalink":"http://yoursite.com/tags/安装/"}]},{"title":"markdown语法","date":"2017-03-24T05:12:31.000Z","path":"2017/03/24/markdown语法/","text":"标题12# 一级标题## 二级标题 标题总共由6级，用1个#到6个#表示，#号后面需要跟一个空格。这里不作示例了。 列表无序列表123* 1* 2* 3 用*表示无序列表，后面需要加一个空格 1 2 3 有序列表1231. 12. 23. 3 用数字加点的形式表示有序列表，注意空格。 1 2 3 引用1&gt; 这里是引用内容 这里是引用内容 链接和图片链接1[百度](www.baidu.com &quot;百度&quot;) 百度 图片12![](http://mouapp.com/Mou_128.png)![](markdown语法/oschina.png) 图片相比链接多了一个感叹号 注意:这里我用的是hexo，需要另下插件才能把本地的图片显示出来。具体参考http://www.tuicool.com/articles/umEBVfI. 此外根目录下_config.yml中的post_asset_folder设置为true 代码块代码放入由`组成的6个点中，上下各3个 123def set_ch(): mpl.rcParams['font.sans-serif'] = ['simhei'] mpl.rcParams['axes.unicode_minus'] = False","tags":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"},{"name":"语法","slug":"语法","permalink":"http://yoursite.com/tags/语法/"}]},{"title":"matplotlib中文显示","date":"2017-03-24T05:08:51.000Z","path":"2017/03/24/matplotlib中文显示/","text":"matplotlib中文显示今天在ubuntu下用matplotlib显示中文的时候出现了乱码，之前在windows上用了下面这段代码就可以了。123def set_ch(): mpl.rcParams['font.sans-serif'] = ['simhei'] # 指定默认字体 mpl.rcParams['axes.unicode_minus'] = False # 解决保存图像是负号'-'显示为方块的问题 但是在ubuntu上还是显示不出。主要原因是ubuntu上没有这个字体。所以从windows上把黑体字体搬到ubuntu的下面这个路径下。1/usr/local/lib/python2.7/dist-packages/matplotlib/mpl-data/fonts 可能每台机子具体路径不太一样，需要自己找下。我是通过print matplotlib.__file__找到的。 然后删除~/.cache/matplotlib的缓冲目录就可以了。","tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"matplotlib","slug":"matplotlib","permalink":"http://yoursite.com/tags/matplotlib/"},{"name":"中文显示","slug":"中文显示","permalink":"http://yoursite.com/tags/中文显示/"}]}]