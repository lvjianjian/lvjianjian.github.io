---
title: Java垃圾收集
date: 2018-05-07 20:26:00
tags: [Java, 垃圾收集]
categories: [Java]
---

# Java垃圾收集

### 1. 对象存活判定算法
* 引用计数法: 每个对象实例有一个引用计数，当有新变量指向这个对象实例时，引用计数器+1；当指向这个对象实例的引用超过了生命周期或者被设置为其它值时，引用计数器-1。对于引用计数为0的对象实例进行垃圾回收。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器-1。但是该方法无法检测出循环引用。

* 可达性分析算法: 将整个程序的引用看成是图，从GC Root开始向下搜索，没有遍历到的节点则为无用节点(不可达对象)。Java中可作为GC Root的对象有以下这些：
	* 虚拟机栈中引用的对象（本地变量表）
	* 方法区中静态属性引用的对象
	* 方法区中常量引用的对象
	* 本地方法栈中引用的对象（Native对象）
	
* 方法区回收：方法区可以不实现垃圾收集。要实现的话主要回收废弃常量和无用的类。回收废弃常量与回收堆中对象类似。而判定一个类是否无用则要满足以下三个条件：
	* 该类的所有实例对象均已被回收。
	* 加载该类的ClassLoader也被回收。
	* 该类对应的java.lang.Class对象没有在任何地方引用，且无法在任何地方通过反射访问该类的方法。

### 2. Java中的四种引用状态：
* 强引用：只要强引用存在，垃圾收集器就不会回收掉该对象。方式：Object obj = new Object()

* 软引用：有用但非必需的对象。在系统将要发生内存溢出之前，将会把这些对象列进垃圾回收范围进行回收。方式：SoftReference

* 弱引用：非必需对象。只能生存到下一次垃圾收集发生之前。方式：WeakReference

* 虚引用：并不会决定其生命周期，且无法通过虚引用来获得对象。唯一目的是在这个对象被收集器回收时收到一个系统通知。方式：PhantomReference。(暂时其实不太明白有什么作用)

### 3. 垃圾收集算法
* 标记-清除算法: 从根集合开始扫描，对存活对象进行标记，标记完毕后，再扫描整个空间中未被标记的进行回收。从效率角度讲，标记和清除过程的效率都不高：从空间角度考虑，会产生大量不连续的内存碎片，导致之后需要分配较大对象时，无法找到足够的连续内存而不得不提前触发垃圾收集。

* 复制算法:  为了解决效率问题所提出的算法。将内存分为两块，每次只用其中一块，当一块内存用完时，将还存活着的对象复制到另外一块上，然后将之前已经用过的内存空间一次性清理掉。该方法在内存分配时无需考虑内存碎片等情况，只需要移动指针按照顺序分配，实现简单运行高效。但是内存缩小为原来一半，代价高。现代商业虚拟机不会按1:1划分。HotSpot默认Eden和Survivor按照8:1。

* 标记-整理算法: 复制算法在对象存活率较高时要进行较多的复制操作，效率将变低，因此提出该算法。和标记-清除算法一样需要进行标记操作，不同的是接下来让所有存活对象都向一端移动，然后清理掉边界以外的内存。

* 分代收集算法: 大多数现代商用虚拟机所采用的算法，其实质是以上算法的结合。根据对象的生命周期不同将内存划分为几块，然后根据各块的特点采用适当的收集算法。一般把Java堆分为新生代和老年代，在新生代中，每次垃圾收集将右大批对象死去，只有少量存活，就选用复制算法; 而老年代中因为对象存活率高、没有额外空间分配担保，就必须使用标记-清理或者标记-整理算法。
			

	
